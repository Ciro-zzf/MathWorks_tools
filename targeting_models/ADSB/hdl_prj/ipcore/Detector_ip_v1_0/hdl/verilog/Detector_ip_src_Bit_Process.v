// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\ModeS_ADI_Codegen\Detector_ip_src_Bit_Process.v
// Created: 2017-07-24 12:12:58
// 
// Generated by MATLAB 9.2 and HDL Coder 3.10
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Detector_ip_src_Bit_Process
// Source Path: ModeS_ADI_Codegen/Detector/Bit Process
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Detector_ip_src_Bit_Process
          (clk,
           reset,
           enb,
           In1,
           Reset_1,
           Enable,
           CurrentBit,
           BitTrigger);


  input   clk;
  input   reset;
  input   enb;
  input   signed [15:0] In1;  // sfix16_En15
  input   Reset_1;
  input   Enable;
  output  CurrentBit;
  output  BitTrigger;

  wire enb_gated;
  reg signed [15:0] Tapped_Delay_reg [0:11];  // sfix16 [12]
  wire signed [15:0] Tapped_Delay_reg_next [0:11];  // sfix16_En15 [12]
  wire signed [15:0] Tapped_Delay_out1 [0:12];  // sfix16_En15 [13]
  wire signed [15:0] Multiport_Selector_out1 [0:5];  // sfix16_En15 [6]
  wire signed [15:0] Logical1_add_cast;  // sfix16_En13
  wire signed [15:0] Logical1_add_cast_1;  // sfix16_En13
  wire signed [15:0] Logical1_add_temp;  // sfix16_En13
  wire signed [15:0] Logical1_add_cast_2;  // sfix16_En13
  wire signed [15:0] Logical1_add_temp_1;  // sfix16_En13
  wire signed [15:0] Logical1_add_cast_3;  // sfix16_En13
  wire signed [15:0] Logical1_add_temp_2;  // sfix16_En13
  wire signed [15:0] Logical1_add_cast_4;  // sfix16_En13
  wire signed [15:0] Logical1_add_temp_3;  // sfix16_En13
  wire signed [15:0] Logical1_add_cast_5;  // sfix16_En13
  wire signed [15:0] Logical1_out1;  // sfix16_En13
  wire signed [15:0] Multiport_Selector_out2 [0:5];  // sfix16_En15 [6]
  wire signed [15:0] Logical0_add_cast;  // sfix16_En13
  wire signed [15:0] Logical0_add_cast_1;  // sfix16_En13
  wire signed [15:0] Logical0_add_temp;  // sfix16_En13
  wire signed [15:0] Logical0_add_cast_2;  // sfix16_En13
  wire signed [15:0] Logical0_add_temp_1;  // sfix16_En13
  wire signed [15:0] Logical0_add_cast_3;  // sfix16_En13
  wire signed [15:0] Logical0_add_temp_2;  // sfix16_En13
  wire signed [15:0] Logical0_add_cast_4;  // sfix16_En13
  wire signed [15:0] Logical0_add_temp_3;  // sfix16_En13
  wire signed [15:0] Logical0_add_cast_5;  // sfix16_En13
  wire signed [15:0] Logical0_out1;  // sfix16_En13
  wire Relational_Operator_relop1;
  reg  Relational_Operator_out1_hold;
  reg [7:0] HDL_Counter_out1;  // uint8
  reg [7:0] HDL_Counter_stepreg;  // uint8
  wire Compare_To_Constant_out1;
  wire Compare_To_Constant1_out1;
  wire Logical_Operator_out1;
  reg  Logical_Operator_out1_hold;

  // <S5>/Enable


  assign enb_gated = Enable && enb;

  // <S5>/Tapped Delay
  always @(posedge clk or posedge reset)
    begin : Tapped_Delay_process
      if (reset == 1'b1) begin
        Tapped_Delay_reg[0] <= 16'sb0000000000000000;
        Tapped_Delay_reg[1] <= 16'sb0000000000000000;
        Tapped_Delay_reg[2] <= 16'sb0000000000000000;
        Tapped_Delay_reg[3] <= 16'sb0000000000000000;
        Tapped_Delay_reg[4] <= 16'sb0000000000000000;
        Tapped_Delay_reg[5] <= 16'sb0000000000000000;
        Tapped_Delay_reg[6] <= 16'sb0000000000000000;
        Tapped_Delay_reg[7] <= 16'sb0000000000000000;
        Tapped_Delay_reg[8] <= 16'sb0000000000000000;
        Tapped_Delay_reg[9] <= 16'sb0000000000000000;
        Tapped_Delay_reg[10] <= 16'sb0000000000000000;
        Tapped_Delay_reg[11] <= 16'sb0000000000000000;
      end
      else begin
        if (enb_gated) begin
          Tapped_Delay_reg[0] <= Tapped_Delay_reg_next[0];
          Tapped_Delay_reg[1] <= Tapped_Delay_reg_next[1];
          Tapped_Delay_reg[2] <= Tapped_Delay_reg_next[2];
          Tapped_Delay_reg[3] <= Tapped_Delay_reg_next[3];
          Tapped_Delay_reg[4] <= Tapped_Delay_reg_next[4];
          Tapped_Delay_reg[5] <= Tapped_Delay_reg_next[5];
          Tapped_Delay_reg[6] <= Tapped_Delay_reg_next[6];
          Tapped_Delay_reg[7] <= Tapped_Delay_reg_next[7];
          Tapped_Delay_reg[8] <= Tapped_Delay_reg_next[8];
          Tapped_Delay_reg[9] <= Tapped_Delay_reg_next[9];
          Tapped_Delay_reg[10] <= Tapped_Delay_reg_next[10];
          Tapped_Delay_reg[11] <= Tapped_Delay_reg_next[11];
        end
      end
    end

  assign Tapped_Delay_out1[0] = Tapped_Delay_reg[0];
  assign Tapped_Delay_out1[1] = Tapped_Delay_reg[1];
  assign Tapped_Delay_out1[2] = Tapped_Delay_reg[2];
  assign Tapped_Delay_out1[3] = Tapped_Delay_reg[3];
  assign Tapped_Delay_out1[4] = Tapped_Delay_reg[4];
  assign Tapped_Delay_out1[5] = Tapped_Delay_reg[5];
  assign Tapped_Delay_out1[6] = Tapped_Delay_reg[6];
  assign Tapped_Delay_out1[7] = Tapped_Delay_reg[7];
  assign Tapped_Delay_out1[8] = Tapped_Delay_reg[8];
  assign Tapped_Delay_out1[9] = Tapped_Delay_reg[9];
  assign Tapped_Delay_out1[10] = Tapped_Delay_reg[10];
  assign Tapped_Delay_out1[11] = Tapped_Delay_reg[11];
  assign Tapped_Delay_out1[12] = In1;
  assign Tapped_Delay_reg_next[0] = Tapped_Delay_reg[1];
  assign Tapped_Delay_reg_next[1] = Tapped_Delay_reg[2];
  assign Tapped_Delay_reg_next[2] = Tapped_Delay_reg[3];
  assign Tapped_Delay_reg_next[3] = Tapped_Delay_reg[4];
  assign Tapped_Delay_reg_next[4] = Tapped_Delay_reg[5];
  assign Tapped_Delay_reg_next[5] = Tapped_Delay_reg[6];
  assign Tapped_Delay_reg_next[6] = Tapped_Delay_reg[7];
  assign Tapped_Delay_reg_next[7] = Tapped_Delay_reg[8];
  assign Tapped_Delay_reg_next[8] = Tapped_Delay_reg[9];
  assign Tapped_Delay_reg_next[9] = Tapped_Delay_reg[10];
  assign Tapped_Delay_reg_next[10] = Tapped_Delay_reg[11];
  assign Tapped_Delay_reg_next[11] = In1;



  assign Multiport_Selector_out1[0] = Tapped_Delay_out1[0];
  assign Multiport_Selector_out1[1] = Tapped_Delay_out1[1];
  assign Multiport_Selector_out1[2] = Tapped_Delay_out1[2];
  assign Multiport_Selector_out1[3] = Tapped_Delay_out1[3];
  assign Multiport_Selector_out1[4] = Tapped_Delay_out1[4];
  assign Multiport_Selector_out1[5] = Tapped_Delay_out1[5];

  // <S5>/Logical1
  assign Logical1_add_cast = {{2{Multiport_Selector_out1[0][15]}}, Multiport_Selector_out1[0][15:2]};
  assign Logical1_add_cast_1 = {{2{Multiport_Selector_out1[1][15]}}, Multiport_Selector_out1[1][15:2]};
  assign Logical1_add_temp = Logical1_add_cast + Logical1_add_cast_1;
  assign Logical1_add_cast_2 = {{2{Multiport_Selector_out1[2][15]}}, Multiport_Selector_out1[2][15:2]};
  assign Logical1_add_temp_1 = Logical1_add_temp + Logical1_add_cast_2;
  assign Logical1_add_cast_3 = {{2{Multiport_Selector_out1[3][15]}}, Multiport_Selector_out1[3][15:2]};
  assign Logical1_add_temp_2 = Logical1_add_temp_1 + Logical1_add_cast_3;
  assign Logical1_add_cast_4 = {{2{Multiport_Selector_out1[4][15]}}, Multiport_Selector_out1[4][15:2]};
  assign Logical1_add_temp_3 = Logical1_add_temp_2 + Logical1_add_cast_4;
  assign Logical1_add_cast_5 = {{2{Multiport_Selector_out1[5][15]}}, Multiport_Selector_out1[5][15:2]};
  assign Logical1_out1 = Logical1_add_temp_3 + Logical1_add_cast_5;



  // <S5>/Multiport Selector
  assign Multiport_Selector_out2[0] = Tapped_Delay_out1[6];
  assign Multiport_Selector_out2[1] = Tapped_Delay_out1[7];
  assign Multiport_Selector_out2[2] = Tapped_Delay_out1[8];
  assign Multiport_Selector_out2[3] = Tapped_Delay_out1[9];
  assign Multiport_Selector_out2[4] = Tapped_Delay_out1[10];
  assign Multiport_Selector_out2[5] = Tapped_Delay_out1[11];

  // <S5>/Logical0
  assign Logical0_add_cast = {{2{Multiport_Selector_out2[0][15]}}, Multiport_Selector_out2[0][15:2]};
  assign Logical0_add_cast_1 = {{2{Multiport_Selector_out2[1][15]}}, Multiport_Selector_out2[1][15:2]};
  assign Logical0_add_temp = Logical0_add_cast + Logical0_add_cast_1;
  assign Logical0_add_cast_2 = {{2{Multiport_Selector_out2[2][15]}}, Multiport_Selector_out2[2][15:2]};
  assign Logical0_add_temp_1 = Logical0_add_temp + Logical0_add_cast_2;
  assign Logical0_add_cast_3 = {{2{Multiport_Selector_out2[3][15]}}, Multiport_Selector_out2[3][15:2]};
  assign Logical0_add_temp_2 = Logical0_add_temp_1 + Logical0_add_cast_3;
  assign Logical0_add_cast_4 = {{2{Multiport_Selector_out2[4][15]}}, Multiport_Selector_out2[4][15:2]};
  assign Logical0_add_temp_3 = Logical0_add_temp_2 + Logical0_add_cast_4;
  assign Logical0_add_cast_5 = {{2{Multiport_Selector_out2[5][15]}}, Multiport_Selector_out2[5][15:2]};
  assign Logical0_out1 = Logical0_add_temp_3 + Logical0_add_cast_5;



  // <S5>/Relational Operator
  assign Relational_Operator_relop1 = Logical1_out1 > Logical0_out1;



  always @(posedge clk or posedge reset)
    begin : CurrentBit_hold_process
      if (reset == 1'b1) begin
        Relational_Operator_out1_hold <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          Relational_Operator_out1_hold <= Relational_Operator_relop1;
        end
      end
    end



  assign CurrentBit = Relational_Operator_out1_hold;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 25
  // 
  // <S5>/HDL Counter
  always @(posedge clk or posedge reset)
    begin : HDL_Counter_step_process
      if (reset == 1'b1) begin
        HDL_Counter_stepreg <= 8'b00000001;
      end
      else begin
        if (enb_gated) begin
          if (Reset_1 == 1'b1) begin
            HDL_Counter_stepreg <= 8'b00000001;
          end
          else if (HDL_Counter_out1 == 8'b00011000) begin
            HDL_Counter_stepreg <= 8'b11101000;
          end
          else begin
            HDL_Counter_stepreg <= 8'b00000001;
          end
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 8'b00000001;
      end
      else begin
        if (enb_gated) begin
          if (Reset_1 == 1'b1) begin
            HDL_Counter_out1 <= 8'b00000001;
          end
          else begin
            HDL_Counter_out1 <= HDL_Counter_out1 + HDL_Counter_stepreg;
          end
        end
      end
    end



  // <S5>/Compare To Constant
  assign Compare_To_Constant_out1 = HDL_Counter_out1 == 8'b00001100;



  // <S5>/Compare To Constant1
  assign Compare_To_Constant1_out1 = HDL_Counter_out1 == 8'b00011001;



  // <S5>/Logical Operator
  assign Logical_Operator_out1 = Compare_To_Constant_out1 | Compare_To_Constant1_out1;



  always @(posedge clk or posedge reset)
    begin : BitTrigger_hold_process
      if (reset == 1'b1) begin
        Logical_Operator_out1_hold <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          Logical_Operator_out1_hold <= Logical_Operator_out1;
        end
      end
    end



  assign BitTrigger = Logical_Operator_out1_hold;

endmodule  // Detector_ip_src_Bit_Process

