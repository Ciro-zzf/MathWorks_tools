// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\ModeS_ADI_Codegen\Detector_ip_src_Detector.v
// Created: 2017-07-24 12:12:58
// 
// Generated by MATLAB 9.2 and HDL Coder 3.10
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// reset_1                       ce_out        1
// bit_process                   ce_out        1
// empty_reg                     ce_out        1
// bit_clk                       ce_out        1
// bits                          ce_out        1
// crc                           ce_out        1
// noise_floor                   ce_out        1
// sync_corr                     ce_out        1
// data                          ce_out        1
// frame_valid                   ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Detector_ip_src_Detector
// Source Path: ModeS_ADI_Codegen/Detector
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Detector_ip_src_Detector
          (clk,
           reset,
           clk_enable,
           I_In,
           Q_In,
           ce_out,
           reset_1,
           bit_process,
           empty_reg,
           bit_clk,
           bits,
           crc,
           noise_floor,
           sync_corr,
           data,
           frame_valid);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [15:0] I_In;  // sfix16_En15
  input   signed [15:0] Q_In;  // sfix16_En15
  output  ce_out;
  output  reset_1;
  output  bit_process;
  output  empty_reg;
  output  bit_clk;
  output  bits;
  output  crc;
  output  signed [15:0] noise_floor;  // sfix16_En16
  output  signed [15:0] sync_corr;  // sfix16_En11
  output  [15:0] data;  // uint16
  output  [15:0] frame_valid;  // uint16

  wire enb;
  reg signed [15:0] Delay17_out1;  // sfix16_En15
  reg signed [15:0] Delay18_out1;  // sfix16_En15
  wire signed [15:0] CalcMagnitude_out1;  // sfix16_En15
  reg signed [15:0] Delay_out1;  // sfix16_En15
  wire signed [15:0] CalcNF_out1;  // sfix16_En16
  reg signed [15:0] Delay13_reg [0:5];  // sfix16 [6]
  wire signed [15:0] Delay13_reg_next [0:5];  // sfix16_En16 [6]
  wire signed [15:0] Delay13_out1;  // sfix16_En16
  reg signed [15:0] Delay1_out1;  // sfix16_En16
  wire signed [15:0] CalcSyncCorr_out1;  // sfix16_En11
  reg signed [15:0] Delay2_out1;  // sfix16_En11
  wire Reset_2;
  wire ActivateBP;
  wire EmptyReg;
  reg  Delay4_out1;
  reg  Delay5_out1;
  reg  Delay6_out1;
  reg signed [15:0] Delay14_reg [0:7];  // sfix16 [8]
  wire signed [15:0] Delay14_reg_next [0:7];  // sfix16_En15 [8]
  wire signed [15:0] Delay14_out1;  // sfix16_En15
  reg signed [15:0] Delay3_out1;  // sfix16_En15
  reg signed [15:0] Delay7_out1;  // sfix16_En15
  wire Bit_Process_out1;
  wire Bit_Process_out2;
  reg  Delay11_out1;
  reg  Delay12_out1;
  reg  Delay9_out1;
  wire g3_out1;
  wire CalcCRC_out1;
  wire CalcCRC_out2;
  wire CalcCRC_out3;
  wire [15:0] Data_Type_Conversion_out1;  // uint16
  wire [15:0] FrameDetect_out1;  // uint16


  assign enb = clk_enable;

  // <S1>/Delay17
  always @(posedge clk or posedge reset)
    begin : Delay17_process
      if (reset == 1'b1) begin
        Delay17_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay17_out1 <= I_In;
        end
      end
    end



  // <S1>/Delay18
  always @(posedge clk or posedge reset)
    begin : Delay18_process
      if (reset == 1'b1) begin
        Delay18_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay18_out1 <= Q_In;
        end
      end
    end



  // <S1>/CalcMagnitude
  Detector_ip_src_CalcMagnitude u_CalcMagnitude (.clk(clk),
                                                 .reset(reset),
                                                 .enb(clk_enable),
                                                 .In1(Delay17_out1),  // sfix16_En15
                                                 .In2(Delay18_out1),  // sfix16_En15
                                                 .Out1(CalcMagnitude_out1)  // sfix16_En15
                                                 );

  // <S1>/Delay
  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= CalcMagnitude_out1;
        end
      end
    end



  // <S1>/CalcNF
  Detector_ip_src_CalcNF u_CalcNF (.clk(clk),
                                   .reset(reset),
                                   .enb(clk_enable),
                                   .In1(Delay_out1),  // sfix16_En15
                                   .Out1(CalcNF_out1)  // sfix16_En16
                                   );

  // <S1>/Delay13
  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_reg[0] <= 16'sb0000000000000000;
        Delay13_reg[1] <= 16'sb0000000000000000;
        Delay13_reg[2] <= 16'sb0000000000000000;
        Delay13_reg[3] <= 16'sb0000000000000000;
        Delay13_reg[4] <= 16'sb0000000000000000;
        Delay13_reg[5] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay13_reg[0] <= Delay13_reg_next[0];
          Delay13_reg[1] <= Delay13_reg_next[1];
          Delay13_reg[2] <= Delay13_reg_next[2];
          Delay13_reg[3] <= Delay13_reg_next[3];
          Delay13_reg[4] <= Delay13_reg_next[4];
          Delay13_reg[5] <= Delay13_reg_next[5];
        end
      end
    end

  assign Delay13_out1 = Delay13_reg[5];
  assign Delay13_reg_next[0] = CalcNF_out1;
  assign Delay13_reg_next[1] = Delay13_reg[0];
  assign Delay13_reg_next[2] = Delay13_reg[1];
  assign Delay13_reg_next[3] = Delay13_reg[2];
  assign Delay13_reg_next[4] = Delay13_reg[3];
  assign Delay13_reg_next[5] = Delay13_reg[4];



  // <S1>/Delay1
  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Delay13_out1;
        end
      end
    end



  // <S1>/CalcSyncCorr
  Detector_ip_src_CalcSyncCorr u_CalcSyncCorr (.clk(clk),
                                               .reset(reset),
                                               .enb(clk_enable),
                                               .In1(Delay_out1),  // sfix16_En15
                                               .Out1(CalcSyncCorr_out1)  // sfix16_En11
                                               );

  // <S1>/Delay2
  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= CalcSyncCorr_out1;
        end
      end
    end



  // <S1>/SyncAndControl
  Detector_ip_src_SyncAndControl u_SyncAndControl (.clk(clk),
                                                   .reset(reset),
                                                   .enb(clk_enable),
                                                   .NoiseFloor(Delay1_out1),  // sfix16_En16
                                                   .SyncCorr(Delay2_out1),  // sfix16_En11
                                                   .Reset_1(Reset_2),
                                                   .ActivateBP(ActivateBP),
                                                   .EmptyReg(EmptyReg)
                                                   );

  // <S1>/Delay4
  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= Reset_2;
        end
      end
    end



  // <S1>/Delay5
  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= ActivateBP;
        end
      end
    end



  assign bit_process = Delay5_out1;

  // <S1>/Delay6
  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= EmptyReg;
        end
      end
    end



  assign empty_reg = Delay6_out1;

  // <S1>/Delay14
  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_reg[0] <= 16'sb0000000000000000;
        Delay14_reg[1] <= 16'sb0000000000000000;
        Delay14_reg[2] <= 16'sb0000000000000000;
        Delay14_reg[3] <= 16'sb0000000000000000;
        Delay14_reg[4] <= 16'sb0000000000000000;
        Delay14_reg[5] <= 16'sb0000000000000000;
        Delay14_reg[6] <= 16'sb0000000000000000;
        Delay14_reg[7] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay14_reg[0] <= Delay14_reg_next[0];
          Delay14_reg[1] <= Delay14_reg_next[1];
          Delay14_reg[2] <= Delay14_reg_next[2];
          Delay14_reg[3] <= Delay14_reg_next[3];
          Delay14_reg[4] <= Delay14_reg_next[4];
          Delay14_reg[5] <= Delay14_reg_next[5];
          Delay14_reg[6] <= Delay14_reg_next[6];
          Delay14_reg[7] <= Delay14_reg_next[7];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[7];
  assign Delay14_reg_next[0] = Delay_out1;
  assign Delay14_reg_next[1] = Delay14_reg[0];
  assign Delay14_reg_next[2] = Delay14_reg[1];
  assign Delay14_reg_next[3] = Delay14_reg[2];
  assign Delay14_reg_next[4] = Delay14_reg[3];
  assign Delay14_reg_next[5] = Delay14_reg[4];
  assign Delay14_reg_next[6] = Delay14_reg[5];
  assign Delay14_reg_next[7] = Delay14_reg[6];



  // <S1>/Delay3
  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Delay14_out1;
        end
      end
    end



  // <S1>/Delay7
  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= Delay3_out1;
        end
      end
    end



  // <S1>/Bit Process
  // 
  // <S1>/Delay10
  // 
  // <S1>/Delay8
  // 
  // <S1>/Delay8
  Detector_ip_src_Bit_Process u_Bit_Process (.clk(clk),
                                             .reset(reset),
                                             .enb(clk_enable),
                                             .In1(Delay7_out1),  // sfix16_En15
                                             .Reset_1(Delay4_out1),
                                             .Enable(Delay5_out1),
                                             .CurrentBit(Bit_Process_out1),
                                             .BitTrigger(Bit_Process_out2)
                                             );

  assign bit_clk = Bit_Process_out2;

  // <S1>/Delay11
  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Delay6_out1;
        end
      end
    end



  // <S1>/Delay12
  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= Delay4_out1;
        end
      end
    end



  // <S1>/Delay9
  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= Delay4_out1;
        end
      end
    end



  // <S1>/g3
  assign g3_out1 = Bit_Process_out2 | Delay9_out1;



  // <S1>/CalcCRC
  Detector_ip_src_CalcCRC u_CalcCRC (.clk(clk),
                                     .reset(reset),
                                     .enb(clk_enable),
                                     .In1(Bit_Process_out1),
                                     .EmptyReg(Delay11_out1),
                                     .Reset_1(Delay12_out1),
                                     .Trigger(g3_out1),
                                     .Bits(CalcCRC_out1),
                                     .CRC(CalcCRC_out2),
                                     .Valid(CalcCRC_out3)
                                     );

  assign bits = CalcCRC_out1;

  assign crc = CalcCRC_out2;

  assign noise_floor = Delay1_out1;

  assign sync_corr = Delay2_out1;

  // <S1>/Data Type Conversion
  assign Data_Type_Conversion_out1 = {15'b0, CalcCRC_out1};



  assign data = Data_Type_Conversion_out1;

  // <S1>/FrameDetect
  Detector_ip_src_FrameDetect u_FrameDetect (.clk(clk),
                                             .reset(reset),
                                             .enb(clk_enable),
                                             .bit_process(Delay5_out1),
                                             .crc_valid(CalcCRC_out3),
                                             .frame_valid(FrameDetect_out1)  // uint16
                                             );

  assign frame_valid = FrameDetect_out1;

  assign ce_out = clk_enable;

  assign reset_1 = Delay4_out1;

endmodule  // Detector_ip_src_Detector

