// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\ModeS_ADI_Codegen\Detector_ip_src_SyncAndControl.v
// Created: 2017-07-24 12:12:58
// 
// Generated by MATLAB 9.2 and HDL Coder 3.10
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Detector_ip_src_SyncAndControl
// Source Path: ModeS_ADI_Codegen/Detector/SyncAndControl
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Detector_ip_src_SyncAndControl
          (clk,
           reset,
           enb,
           NoiseFloor,
           SyncCorr,
           Reset_1,
           ActivateBP,
           EmptyReg);

  parameter is_SyncAndControl_IN_BitProcess = 3'd0, is_SyncAndControl_IN_ClearBP = 3'd1, is_SyncAndControl_IN_EmptyReg = 3'd2, is_SyncAndControl_IN_SyncSearch = 3'd3, is_SyncAndControl_IN_WaitForT0 = 3'd4;

  input   clk;
  input   reset;
  input   enb;
  input   signed [15:0] NoiseFloor;  // sfix16_En16
  input   signed [15:0] SyncCorr;  // sfix16_En11
  output  Reset_1;
  output  ActivateBP;
  output  EmptyReg;

  reg [2:0] is_SyncAndControl;  // uint8
  reg [15:0] SamplesIn;  // uint16
  reg signed [13:0] maxSync;  // sfix14_En9
  reg [15:0] CRCClocks;  // uint16
  reg [7:0] T0Delay;  // uint8
  reg  Reset_reg;
  reg  ActivateBP_reg;
  reg  EmptyReg_reg;
  reg [2:0] is_SyncAndControl_next;  // enum type is_SyncAndControl (5 enums)
  reg [15:0] SamplesIn_next;  // uint16
  reg signed [13:0] maxSync_next;  // sfix14_En9
  reg [15:0] CRCClocks_next;  // uint16
  reg [7:0] T0Delay_next;  // uint8
  reg  Reset_reg_next;
  reg  ActivateBP_reg_next;
  reg  EmptyReg_reg_next;
  reg [7:0] T0Delay_temp;  // uint8
  reg signed [31:0] cast;  // sfix32_En16
  reg signed [22:0] mul_temp;  // sfix23_En16
  reg signed [31:0] cast_0;  // sfix32_En16
  reg signed [15:0] cast_1;  // sfix16_En11
  reg signed [15:0] cast_2;  // sfix16_En11


  always @(posedge clk or posedge reset)
    begin : SyncAndControl_process
      if (reset == 1'b1) begin
        SamplesIn <= 16'd0;
        maxSync <= 14'sb00000000000000;
        CRCClocks <= 16'd0;
        T0Delay <= 8'd0;
        Reset_reg <= 1'b0;
        ActivateBP_reg <= 1'b0;
        EmptyReg_reg <= 1'b0;
        //Entry: Detector/SyncAndControl
        //Entry Internal: Detector/SyncAndControl
        //Transition: '<S11>:2'
        is_SyncAndControl <= is_SyncAndControl_IN_SyncSearch;
      end
      else begin
        if (enb) begin
          is_SyncAndControl <= is_SyncAndControl_next;
          SamplesIn <= SamplesIn_next;
          maxSync <= maxSync_next;
          CRCClocks <= CRCClocks_next;
          T0Delay <= T0Delay_next;
          Reset_reg <= Reset_reg_next;
          ActivateBP_reg <= ActivateBP_reg_next;
          EmptyReg_reg <= EmptyReg_reg_next;
        end
      end
    end

  always @(is_SyncAndControl, NoiseFloor, SyncCorr, SamplesIn, maxSync, CRCClocks,
       T0Delay, Reset_reg, ActivateBP_reg, EmptyReg_reg) begin
    SamplesIn_next = SamplesIn;
    CRCClocks_next = CRCClocks;
    T0Delay_temp = T0Delay;
    Reset_reg_next = Reset_reg;
    ActivateBP_reg_next = ActivateBP_reg;
    EmptyReg_reg_next = EmptyReg_reg;
    is_SyncAndControl_next = is_SyncAndControl;
    maxSync_next = maxSync;
    //Gateway: Detector/SyncAndControl
    //During: Detector/SyncAndControl
    case ( is_SyncAndControl)
      is_SyncAndControl_IN_BitProcess :
        begin
          //During 'BitProcess': '<S11>:3'
          if (SamplesIn >= 16'b0000010001001100) begin
            //Transition: '<S11>:16'
            EmptyReg_reg_next = 1'b1;
            is_SyncAndControl_next = is_SyncAndControl_IN_EmptyReg;
            //Entry 'EmptyReg': '<S11>:7'
            CRCClocks_next = 16'd1;
          end
          else begin
            cast_2 = {maxSync, 2'b00};
            if ((SyncCorr > cast_2) && (SamplesIn < 16'b0000000000110010)) begin
              //Transition: '<S11>:27'
              Reset_reg_next = 1'b1;
              SamplesIn_next = 16'd0;
              maxSync_next = SyncCorr[15:2];
              is_SyncAndControl_next = is_SyncAndControl_IN_WaitForT0;
              //Entry 'WaitForT0': '<S11>:22'
              T0Delay_temp = 8'd1;
            end
            else begin
              //Transition: '<S11>:29'
              is_SyncAndControl_next = is_SyncAndControl_IN_BitProcess;
              //Entry 'BitProcess': '<S11>:3'
              SamplesIn_next = SamplesIn + 16'd1;
              Reset_reg_next = 1'b0;
            end
          end
        end
      is_SyncAndControl_IN_ClearBP :
        begin
          //During 'ClearBP': '<S11>:35'
          if (SamplesIn > 16'b0000000001100100) begin
            //Transition: '<S11>:38'
            is_SyncAndControl_next = is_SyncAndControl_IN_SyncSearch;
          end
          else begin
            //Transition: '<S11>:40'
            is_SyncAndControl_next = is_SyncAndControl_IN_ClearBP;
            //Entry 'ClearBP': '<S11>:35'
            SamplesIn_next = SamplesIn + 16'd1;
          end
        end
      is_SyncAndControl_IN_EmptyReg :
        begin
          //During 'EmptyReg': '<S11>:7'
          if (CRCClocks >= 16'b0000000100101100) begin
            //Transition: '<S11>:36'
            maxSync_next = 14'sb00000000000000;
            ActivateBP_reg_next = 1'b0;
            Reset_reg_next = 1'b0;
            EmptyReg_reg_next = 1'b0;
            is_SyncAndControl_next = is_SyncAndControl_IN_ClearBP;
            //Entry 'ClearBP': '<S11>:35'
            SamplesIn_next = 16'd1;
          end
          else begin
            //Transition: '<S11>:39'
            is_SyncAndControl_next = is_SyncAndControl_IN_EmptyReg;
            //Entry 'EmptyReg': '<S11>:7'
            CRCClocks_next = CRCClocks + 16'd1;
          end
        end
      is_SyncAndControl_IN_SyncSearch :
        begin
          //During 'SyncSearch': '<S11>:1'
          cast = {{11{SyncCorr[15]}}, {SyncCorr, 5'b00000}};
          mul_temp = 7'sb0101000 * NoiseFloor;
          cast_0 = {{9{mul_temp[22]}}, mul_temp};
          if (cast > cast_0) begin
            //Transition: '<S11>:23'
            ActivateBP_reg_next = 1'b1;
            maxSync_next = SyncCorr[15:2];
            SamplesIn_next = 16'd0;
            Reset_reg_next = 1'b1;
            is_SyncAndControl_next = is_SyncAndControl_IN_WaitForT0;
            //Entry 'WaitForT0': '<S11>:22'
            T0Delay_temp = 8'd1;
          end
        end
      default :
        begin
          //During 'WaitForT0': '<S11>:22'
          if (T0Delay > 8'b00011001) begin
            //Transition: '<S11>:25'
            is_SyncAndControl_next = is_SyncAndControl_IN_BitProcess;
            //Entry 'BitProcess': '<S11>:3'
            SamplesIn_next = SamplesIn + 16'd1;
            Reset_reg_next = 1'b0;
          end
          else begin
            cast_1 = {maxSync, 2'b00};
            if (SyncCorr > cast_1) begin
              //Transition: '<S11>:30'
              T0Delay_temp = 8'd0;
              maxSync_next = SyncCorr[15:2];
            end
            else begin
              //Transition: '<S11>:31'
            end
            is_SyncAndControl_next = is_SyncAndControl_IN_WaitForT0;
            //Entry 'WaitForT0': '<S11>:22'
            T0Delay_temp = T0Delay_temp + 8'd1;
          end
        end
    endcase
    T0Delay_next = T0Delay_temp;
  end

  assign Reset_1 = Reset_reg_next;
  assign ActivateBP = ActivateBP_reg_next;
  assign EmptyReg = EmptyReg_reg_next;



endmodule  // Detector_ip_src_SyncAndControl

