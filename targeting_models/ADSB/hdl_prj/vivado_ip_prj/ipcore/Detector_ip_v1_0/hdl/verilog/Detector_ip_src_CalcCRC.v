// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\ModeS_ADI_Codegen\Detector_ip_src_CalcCRC.v
// Created: 2017-07-24 12:12:58
// 
// Generated by MATLAB 9.2 and HDL Coder 3.10
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Detector_ip_src_CalcCRC
// Source Path: ModeS_ADI_Codegen/Detector/CalcCRC
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Detector_ip_src_CalcCRC
          (clk,
           reset,
           enb,
           In1,
           EmptyReg,
           Reset_1,
           Trigger,
           Bits,
           CRC,
           Valid);


  input   clk;
  input   reset;
  input   enb;
  input   In1;
  input   EmptyReg;
  input   Reset_1;
  input   Trigger;
  output  Bits;
  output  CRC;
  output  Valid;

  wire enb_gated;
  reg  Trigger_delayed;
  wire Trigger_emulated;
  wire In1_bypass;
  reg  In1_last_value;
  wire crc24f_out1;
  wire crc24f_out1_bypass;
  reg  crc24f_out1_last_value;
  wire Logical_Operator_out1;
  wire Logical_Operator1_out1;
  wire Check_CRC_out1;
  wire Check_CRC_out1_bypass;
  reg  Check_CRC_out1_last_value;

  // <S6>/Trigger


  always @(posedge clk or posedge reset)
    begin : Trigger_delay
      if (reset) begin
        Trigger_delayed <= 1'b1;
      end
      else begin
        if (enb) begin
          Trigger_delayed <= Trigger;
        end
      end
    end

  assign Trigger_emulated = !Trigger_delayed && Trigger;

  assign enb_gated = Trigger_emulated && enb;

  always @(posedge clk or posedge reset)
    begin : Bits_bypass_process
      if (reset == 1'b1) begin
        In1_last_value <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          In1_last_value <= In1_bypass;
        end
      end
    end



  assign In1_bypass = (Trigger_emulated == 1'b0 ? In1_last_value :
              In1);



  assign Bits = In1_bypass;

  // <S6>/crc24f
  Detector_ip_src_crc24f u_crc24f (.clk(clk),
                                   .reset(reset),
                                   .enb(enb_gated),
                                   .bits_in(In1),
                                   .flag88(EmptyReg),
                                   .reset_1(Reset_1),
                                   .crc_out(crc24f_out1)
                                   );

  always @(posedge clk or posedge reset)
    begin : CRC_bypass_process
      if (reset == 1'b1) begin
        crc24f_out1_last_value <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          crc24f_out1_last_value <= crc24f_out1_bypass;
        end
      end
    end



  assign crc24f_out1_bypass = (Trigger_emulated == 1'b0 ? crc24f_out1_last_value :
              crc24f_out1);



  assign CRC = crc24f_out1_bypass;

  // <S6>/Logical Operator
  assign Logical_Operator_out1 = In1 & EmptyReg;



  // <S6>/Logical Operator1
  assign Logical_Operator1_out1 = crc24f_out1 & EmptyReg;



  // <S6>/Check_CRC
  Detector_ip_src_Check_CRC u_Check_CRC (.clk(clk),
                                         .reset(reset),
                                         .enb(enb_gated),
                                         .Bits(Logical_Operator_out1),
                                         .CRC(Logical_Operator1_out1),
                                         .rst(Reset_1),
                                         .CRC_Chk(Check_CRC_out1)
                                         );

  always @(posedge clk or posedge reset)
    begin : Valid_bypass_process
      if (reset == 1'b1) begin
        Check_CRC_out1_last_value <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          Check_CRC_out1_last_value <= Check_CRC_out1_bypass;
        end
      end
    end



  assign Check_CRC_out1_bypass = (Trigger_emulated == 1'b0 ? Check_CRC_out1_last_value :
              Check_CRC_out1);



  assign Valid = Check_CRC_out1_bypass;

endmodule  // Detector_ip_src_CalcCRC

